<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>eddie status</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #1a1b26;
      --panel: #16161e;
      --text: #c0caf5;
      --muted: #565f89;
      --border: #292e42;
      --healthy: #9ece6a;
      --failing: #f7768e;
      --unknown: #e0af68;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font: 13px/1.35 "SF Pro Text", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    main {
      max-width: 1300px;
      margin: 1rem auto;
      padding: 0 0.75rem;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }
    header {
      padding: 0.65rem 0.85rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem 1rem;
      align-items: baseline;
      justify-content: space-between;
    }
    h1 {
      margin: 0;
      font-size: 0.88rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      text-transform: lowercase;
    }
    .meta {
      color: var(--muted);
      font-size: 0.8rem;
    }
    .table-wrap {
      max-height: calc(100vh - 7rem);
      overflow: auto;
      padding: 0 0.6rem 0.6rem;
    }
    table {
      width: max-content;
      min-width: 100%;
      border-collapse: collapse;
      table-layout: auto;
      font-size: 0.76rem;
    }
    thead th {
      position: sticky;
      top: 0;
      z-index: 1;
      background: var(--panel);
      text-align: left;
      font-weight: 600;
      font-size: 0.68rem;
      color: var(--muted);
      letter-spacing: 0.02em;
      text-transform: uppercase;
      padding: 0.36rem 0.52rem;
      border-bottom: 1px solid var(--border);
      white-space: nowrap;
    }
    tbody td {
      padding: 0.28rem 0.52rem;
      border-bottom: 1px solid var(--border);
      vertical-align: middle;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    tbody tr:nth-child(odd) td { background: #1a1e2f; }
    tbody tr:last-child td { border-bottom: 0; }
    tbody tr:hover td { background: #1f2335; }
    code {
      font: 0.74rem/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: var(--muted);
    }
    .state-healthy { color: var(--healthy); font-weight: 600; }
    .state-failing { color: var(--failing); font-weight: 600; }
    .state-unknown { color: var(--unknown); font-weight: 600; }
    .bool { color: var(--muted); }
  </style>
</head>
<body>
  <main>
    <article class="panel">
      <header>
        <h1>eddie status</h1>
        <div class="meta">
          <span>generated <time id="generated-at" datetime="{{ .GeneratedAt }}">{{ .GeneratedAt }}</time></span>
          <span>•</span>
          <span id="spec-count">{{ .SpecCount }} specs</span>
          <span>•</span>
          <span id="stream-state">connecting…</span>
        </div>
      </header>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th scope="col">Name</th>
              <th scope="col">State</th>
              <th scope="col">Off</th>
              <th scope="col">State?</th>
              <th scope="col">Fail</th>
              <th scope="col">Succ</th>
              <th scope="col">Started</th>
              <th scope="col">Duration</th>
              <th scope="col">Source</th>
            </tr>
          </thead>
          <tbody id="status-rows">
            {{ range .Rows }}
            <tr>
              <td title="{{ .Name }}">{{ .Name }}</td>
              <td><span class="{{ .StateClass }}">{{ .State }}</span></td>
              <td class="bool">{{ .Disabled }}</td>
              <td class="bool">{{ .HasState }}</td>
              <td>{{ .ConsecutiveFailures }}</td>
              <td>{{ .ConsecutiveSuccesses }}</td>
              <td><time datetime="{{ .LastCycleStartedAt }}">{{ .LastCycleStartedAt }}</time></td>
              <td><time datetime="{{ .LastCycleAt }}">{{ .LastCycleAt }}</time></td>
              <td title="{{ .SourcePath }}"><code>{{ .SourcePath }}</code></td>
            </tr>
            {{ end }}
          </tbody>
        </table>
      </div>
    </article>
  </main>
  <script>
    (() => {
      const generatedAtEl = document.getElementById("generated-at");
      const specCountEl = document.getElementById("spec-count");
      const rowsEl = document.getElementById("status-rows");
      const streamStateEl = document.getElementById("stream-state");
      if (!generatedAtEl || !specCountEl || !rowsEl || !streamStateEl) return;

      function stateClass(state) {
        if (state === "healthy") return "state-healthy";
        if (state === "failing") return "state-failing";
        return "state-unknown";
      }

      function setStreamState(text) {
        streamStateEl.textContent = text;
      }

      const timeFormatter = new Intl.DateTimeFormat(undefined, {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false,
        timeZoneName: "short",
      });

      function parseTimestamp(value) {
        if (!value || value === "never") return NaN;
        const ms = Date.parse(value);
        return Number.isNaN(ms) ? NaN : ms;
      }

      function formatStarted(value) {
        const ms = parseTimestamp(value);
        if (Number.isNaN(ms)) return value || "never";
        const formatted = timeFormatter.format(new Date(ms));
        const match = formatted.match(/(GMT[+-]\d{1,2}|UTC|[A-Z]{2,})/);
        if (!match) return formatted;
        return formatted.replace(match[1], "(" + match[1] + ")");
      }

      function formatDuration(startValue, endValue) {
        const start = parseTimestamp(startValue);
        const end = parseTimestamp(endValue);
        if (Number.isNaN(start) || Number.isNaN(end)) return "never";
        const totalMs = Math.max(0, end - start);
        if (totalMs < 1000) return totalMs + "ms";
        const totalSeconds = Math.round(totalMs / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        let out = "";
        if (hours > 0) out += hours + "h";
        if (minutes > 0 || hours > 0) out += minutes + "m";
        out += seconds + "s";
        return out;
      }

      function render(snapshot) {
        if (!snapshot || typeof snapshot !== "object") return;

        const generatedAtRaw = String(snapshot.generated_at || "unknown");
        generatedAtEl.textContent = formatStarted(generatedAtRaw);
        generatedAtEl.setAttribute("datetime", generatedAtRaw);

        const rows = Array.isArray(snapshot.rows) ? snapshot.rows : [];
        specCountEl.textContent = String(rows.length) + " specs";

        rowsEl.textContent = "";
        rows.forEach((row) => {
          const name = String(row.name ?? "");
          const sourcePath = String(row.source_path ?? "");
          const state = String(row.state ?? "unknown");
          const disabled = String(Boolean(row.disabled));
          const hasState = String(Boolean(row.has_state));
          const failures = String(row.consecutive_failures ?? 0);
          const successes = String(row.consecutive_successes ?? 0);
          const lastStartedRaw = String(row.last_cycle_started_at ?? "never");
          const lastCompletedRaw = String(row.last_cycle_at ?? "never");
          const lastStarted = formatStarted(lastStartedRaw);
          const lastDuration = formatDuration(lastStartedRaw, lastCompletedRaw);

          const tr = document.createElement("tr");

          const nameTd = document.createElement("td");
          nameTd.title = name;
          nameTd.textContent = name;
          tr.appendChild(nameTd);

          const stateTd = document.createElement("td");
          const stateSpan = document.createElement("span");
          stateSpan.className = stateClass(state);
          stateSpan.textContent = state;
          stateTd.appendChild(stateSpan);
          tr.appendChild(stateTd);

          const offTd = document.createElement("td");
          offTd.className = "bool";
          offTd.textContent = disabled;
          tr.appendChild(offTd);

          const hasStateTd = document.createElement("td");
          hasStateTd.className = "bool";
          hasStateTd.textContent = hasState;
          tr.appendChild(hasStateTd);

          const failTd = document.createElement("td");
          failTd.textContent = failures;
          tr.appendChild(failTd);

          const succTd = document.createElement("td");
          succTd.textContent = successes;
          tr.appendChild(succTd);

          const startedTd = document.createElement("td");
          const startedTime = document.createElement("time");
          startedTime.setAttribute("datetime", lastStartedRaw);
          startedTime.textContent = lastStarted;
          startedTd.appendChild(startedTime);
          tr.appendChild(startedTd);

          const durationTd = document.createElement("td");
          const durationTime = document.createElement("time");
          durationTime.setAttribute("datetime", lastCompletedRaw);
          durationTime.textContent = lastDuration;
          durationTd.appendChild(durationTime);
          tr.appendChild(durationTd);

          const sourceTd = document.createElement("td");
          sourceTd.title = sourcePath;
          const sourceCode = document.createElement("code");
          sourceCode.textContent = sourcePath;
          sourceTd.appendChild(sourceCode);
          tr.appendChild(sourceTd);

          rowsEl.appendChild(tr);
        });
      }

      updateStaticRows();

      if (!window.EventSource) {
        setStreamState("live updates unsupported");
        return;
      }

      const stream = new EventSource("/events");
      stream.addEventListener("snapshot", (event) => {
        try {
          render(JSON.parse(event.data));
          setStreamState("live");
        } catch {
          setStreamState("parse error");
        }
      });
      stream.onopen = () => setStreamState("live");
      stream.onerror = () => setStreamState("reconnecting…");

      function updateStaticRows() {
        const generatedRaw = generatedAtEl.getAttribute("datetime") || generatedAtEl.textContent;
        generatedAtEl.textContent = formatStarted(generatedRaw);
        const rows = rowsEl.querySelectorAll("tr");
        rows.forEach((row) => {
          const timeEls = row.querySelectorAll("time");
          if (timeEls.length < 2) return;
          const startedEl = timeEls[0];
          const doneEl = timeEls[1];
          const startedRaw = startedEl.getAttribute("datetime") || "never";
          const doneRaw = doneEl.getAttribute("datetime") || "never";
          startedEl.textContent = formatStarted(startedRaw);
          doneEl.textContent = formatDuration(startedRaw, doneRaw);
        });
      }

    })();
  </script>
</body>
</html>